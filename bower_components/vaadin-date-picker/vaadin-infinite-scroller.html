<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
--><link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/legacy/class.html">
<link rel="import" href="../polymer/lib/legacy/templatizer-behavior.html">

<dom-module id="vaadin-infinite-scroller">
  <template>
    <style>
      :host {
        display: block;
        overflow: hidden;
        height: 500px;
      }

      #scroller {
        position: relative;
        height: 100%;
        overflow: auto;
        outline: none;
        margin-right: -40px;
        -webkit-overflow-scrolling: touch;
        -ms-overflow-style: none;
        overflow-x: hidden;
      }

      #scroller.notouchscroll {
        -webkit-overflow-scrolling: auto;
      }

      #scroller::-webkit-scrollbar {
        display: none;
      }

      .buffer {
        position: absolute;
        width: var(--vaadin-infinite-scroller-buffer-width, 100%);
        box-sizing: border-box;
        padding-right: 40px;
        top: var(--vaadin-infinite-scroller-buffer-offset, 0);
        animation: fadein 0.2s;
      }

      @keyframes fadein {
        from { opacity: 0; }
        to { opacity: 1; }
      }
    </style>

    <div id="scroller" on-scroll="_scroll">
      <div class="buffer"></div>
      <div class="buffer"></div>
      <div id="fullHeight"></div>
    </div>
  </template>
</dom-module>

<script>
{
  /**
   * @private
   */
  var InfiniteScrollerElement = function (_Polymer$Element) {
    babelHelpers.inherits(InfiniteScrollerElement, _Polymer$Element);

    function InfiniteScrollerElement() {
      babelHelpers.classCallCheck(this, InfiniteScrollerElement);
      return babelHelpers.possibleConstructorReturn(this, (InfiniteScrollerElement.__proto__ || Object.getPrototypeOf(InfiniteScrollerElement)).apply(this, arguments));
    }

    babelHelpers.createClass(InfiniteScrollerElement, [{
      key: 'ready',
      value: function ready() {
        babelHelpers.get(InfiniteScrollerElement.prototype.__proto__ || Object.getPrototypeOf(InfiniteScrollerElement.prototype), 'ready', this).call(this);

        this._buffers = Array.prototype.slice.call(this.root.querySelectorAll('.buffer'));

        this.$.fullHeight.style.height = this._initialScroll * 2 + 'px';

        var tpl = this.querySelector('template');
        this._TemplateClass = Polymer.Templatize.templatize(tpl, this, {
          forwardHostProp: function forwardHostProp(prop, value) {
            if (prop !== 'index') {
              this._buffers.forEach(function (buffer) {
                [].forEach.call(buffer.children, function (insertionPoint) {
                  insertionPoint._itemWrapper.instance[prop] = value;
                });
              });
            }
          }
        });

        // Firefox interprets elements with overflow:auto as focusable
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
        var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        if (isFirefox) {
          this.$.scroller.tabIndex = -1;
        }
      }
    }, {
      key: '_activated',
      value: function _activated(active) {
        if (active && !this._initialized) {
          this._createPool();
          this._initialized = true;
        }
      }
    }, {
      key: '_finishInit',
      value: function _finishInit() {
        var _this2 = this;

        if (!this._initDone) {
          // Once the first set of items start fading in, stamp the rest
          this._buffers.forEach(function (buffer) {
            [].forEach.call(buffer.children, function (insertionPoint) {
              return _this2._ensureStampedInstance(insertionPoint._itemWrapper);
            });
          }, this);

          if (!this._buffers[0].translateY) {
            this._reset();
          }

          this._initDone = true;
        }
      }
    }, {
      key: '_translateBuffer',
      value: function _translateBuffer(up) {
        var index = up ? 1 : 0;
        this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);
        this._buffers[index].style.transform = 'translate3d(0, ' + this._buffers[index].translateY + 'px, 0)';
        this._buffers[index].updated = false;
        this._buffers.reverse();
      }
    }, {
      key: '_scroll',
      value: function _scroll() {
        var _this3 = this;

        if (this._scrollDisabled) {
          return;
        }

        var scrollTop = this.$.scroller.scrollTop;
        if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
          // Scrolled near the end/beginning of the scrollable area -> reset.
          this._initialIndex = ~~this.position;
          this._reset();
        }

        // Check if we scrolled enough to translate the buffer positions.
        var bufferOffset = this.root.querySelector('.buffer').offsetTop;
        var upperThresholdReached = scrollTop > this._buffers[1].translateY + this.itemHeight + bufferOffset;
        var lowerThresholdReached = scrollTop < this._buffers[0].translateY + this.itemHeight + bufferOffset;

        if (upperThresholdReached || lowerThresholdReached) {
          this._translateBuffer(lowerThresholdReached);
          this._updateClones();
        }

        if (!this._preventScrollEvent) {
          this.dispatchEvent(new CustomEvent('custom-scroll', { bubbles: false, composed: true }));
          this._mayHaveMomentum = true;
        }
        this._preventScrollEvent = false;

        this._debouncerScrollFinish = Polymer.Debouncer.debounce(this._debouncerScrollFinish, Polymer.Async.timeOut.after(200), function () {
          var scrollerRect = _this3.$.scroller.getBoundingClientRect();
          if (!_this3._isVisible(_this3._buffers[0], scrollerRect) && !_this3._isVisible(_this3._buffers[1], scrollerRect)) {
            _this3.position = _this3.position;
          }
        });
      }

      /**
       * Current scroller position as index. Can be a fractional number.
       *
       * @type {Number}
       */

    }, {
      key: '_reset',
      value: function _reset() {
        var _this4 = this;

        this._scrollDisabled = true;
        this.$.scroller.scrollTop = this._initialScroll;
        this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
        this._buffers[1].translateY = this._initialScroll;
        this._buffers.forEach(function (buffer) {
          buffer.style.transform = 'translate3d(0, ' + buffer.translateY + 'px, 0)';
        });
        this._buffers[0].updated = this._buffers[1].updated = false;
        this._updateClones(true);

        this._debouncerUpdateClones = Polymer.Debouncer.debounce(this._debouncerUpdateClones, Polymer.Async.timeOut.after(200), function () {
          _this4._buffers[0].updated = _this4._buffers[1].updated = false;
          _this4._updateClones();
        });

        this._scrollDisabled = false;
      }
    }, {
      key: '_createPool',
      value: function _createPool() {
        var _this5 = this;

        var container = this.getBoundingClientRect();
        this._buffers.forEach(function (buffer) {
          var _loop = function _loop() {
            var itemWrapper = document.createElement('div');
            itemWrapper.style.height = _this5.itemHeight + 'px';
            itemWrapper.instance = {};

            var contentId = Vaadin.InfiniteScrollerElement._contentIndex = Vaadin.InfiniteScrollerElement._contentIndex + 1 || 0;
            var slotName = 'vaadin-infinite-scroller-item-content-' + contentId;

            var insertionPoint = document.createElement('slot');
            insertionPoint.setAttribute('name', slotName);
            insertionPoint._itemWrapper = itemWrapper;
            buffer.appendChild(insertionPoint);

            itemWrapper.setAttribute('slot', slotName);
            _this5.appendChild(itemWrapper);

            // This is needed by IE
            Polymer.dom.flush();

            setTimeout(function () {
              // Only stamp the visible instances first
              if (_this5._isVisible(itemWrapper, container)) {
                _this5._ensureStampedInstance(itemWrapper);
              }
            }, 1); // Wait for first reset
          };

          for (var i = 0; i < _this5.bufferSize; i++) {
            _loop();
          }
        }, this);

        setTimeout(function () {
          Polymer.RenderStatus.afterNextRender(_this5, _this5._finishInit.bind(_this5));
        }, 1);
      }
    }, {
      key: '_ensureStampedInstance',
      value: function _ensureStampedInstance(itemWrapper) {
        if (itemWrapper.firstElementChild) {
          return;
        }

        var tmpInstance = itemWrapper.instance;

        itemWrapper.instance = new this._TemplateClass({});
        itemWrapper.appendChild(itemWrapper.instance.root);

        Object.keys(tmpInstance).forEach(function (prop) {
          itemWrapper.instance.set(prop, tmpInstance[prop]);
        });
      }
    }, {
      key: '_updateClones',
      value: function _updateClones(viewPortOnly) {
        var _this6 = this;

        this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;

        var scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : undefined;
        this._buffers.forEach(function (buffer, bufferIndex) {
          if (!buffer.updated) {
            var firstIndex = _this6._firstIndex + _this6.bufferSize * bufferIndex;

            [].forEach.call(buffer.children, function (insertionPoint, index) {
              var itemWrapper = insertionPoint._itemWrapper;
              if (!viewPortOnly || _this6._isVisible(itemWrapper, scrollerRect)) {
                itemWrapper.instance.index = firstIndex + index;
              }
            });
            buffer.updated = true;
          }
        }, this);
      }
    }, {
      key: '_isVisible',
      value: function _isVisible(element, container) {
        var rect = element.getBoundingClientRect();
        return rect.bottom > container.top && rect.top < container.bottom;
      }
    }, {
      key: 'position',
      set: function set(index) {
        var _this7 = this;

        this._preventScrollEvent = true;
        if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
          this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
        } else {
          this._initialIndex = ~~index;
          this._reset();
          this._scrollDisabled = true;
          this.$.scroller.scrollTop += index % 1 * this.itemHeight;
          this._scrollDisabled = false;
        }

        if (this._mayHaveMomentum) {
          // Stop the possible iOS Safari momentum with -webkit-overflow-scrolling: auto;
          this.$.scroller.classList.add('notouchscroll');
          this._mayHaveMomentum = false;

          setTimeout(function () {
            // Restore -webkit-overflow-scrolling: touch; after a small delay.
            _this7.$.scroller.classList.remove('notouchscroll');
          }, 10);
        }
      }

      /**
       * @private
       */
      ,
      get: function get() {
        return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
      }
    }, {
      key: 'itemHeight',
      get: function get() {
        if (!this._itemHeightVal) {
          var itemHeight = window.ShadyCSS ? window.ShadyCSS.getComputedStyleValue(this, '--vaadin-infinite-scroller-item-height') : getComputedStyle(this).getPropertyValue('--vaadin-infinite-scroller-item-height');
          this._itemHeightVal = parseInt(itemHeight);
        }

        return this._itemHeightVal;
      }
    }, {
      key: '_bufferHeight',
      get: function get() {
        return this.itemHeight * this.bufferSize;
      }
    }], [{
      key: 'is',
      get: function get() {
        return 'vaadin-infinite-scroller';
      }
    }, {
      key: 'properties',
      get: function get() {
        return {

          /**
           * Count of individual items in each buffer.
           * The scroller has 2 buffers altogether so bufferSize of 20
           * will result in 40 buffered DOM items in total.
           * Changing after initialization not supported.
           */
          bufferSize: {
            type: Number,
            value: 20
          },

          /**
           * The amount of initial scroll top. Needed in order for the
           * user to be able to scroll backwards.
           */
          _initialScroll: {
            value: 500000
          },

          /**
           * The index/position mapped at _initialScroll point.
           */
          _initialIndex: {
            value: 0
          },

          _buffers: Array,

          _preventScrollEvent: Boolean,

          _mayHaveMomentum: Boolean,

          _initialized: Boolean,

          active: {
            type: Boolean,
            observer: '_activated'
          }
        };
      }
    }]);
    return InfiniteScrollerElement;
  }(Polymer.Element);

  customElements.define(InfiniteScrollerElement.is, InfiniteScrollerElement);

  /**
   * @namespace Vaadin
   */
  window.Vaadin = window.Vaadin || {};
  Vaadin.InfiniteScrollerElement = InfiniteScrollerElement;
}</script>
